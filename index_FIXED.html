<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Money Budgeter</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0a6bff" />

  <link rel="manifest" href="/manifest.json" />
  <link rel="apple-touch-icon" href="/icon-192.png" />
  <link rel="stylesheet" href="style.css" />
</head>

<body class="light-mode">
  <div class="calculator-box">

    <!-- ‚úÖ Profile badge (top-left) -->
    <div id="profile-badge" onclick="toggleProfileMenu()" aria-label="Profiles">üôÇ</div>

    <!-- ‚úÖ Settings icon (top-right) -->
    <div id="settings-icon" onclick="openSettings()">‚öôÔ∏è</div>

    <h1 id="title">Money Budgeter</h1>
    <div id="clock">üïí --:--</div>
    <div id="budget">Budget: $0.00</div>

    <input id="input-display" placeholder="0.00" readonly />

    <!-- ‚úÖ Adjustable quick amounts bar -->
    <div id="quickBar" class="quick-bar"></div>

    <div class="numpad">
      <button onclick="appendNumber('1')">1</button>
      <button onclick="appendNumber('2')">2</button>
      <button onclick="appendNumber('3')">3</button>
      <button onclick="appendNumber('4')">4</button>
      <button onclick="appendNumber('5')">5</button>
      <button onclick="appendNumber('6')">6</button>
      <button onclick="appendNumber('7')">7</button>
      <button onclick="appendNumber('8')">8</button>
      <button onclick="appendNumber('9')">9</button>
      <button id="zeroBtn" onclick="appendNumber('0')">0</button>

      <button id="decimalBtn" onclick="appendDecimal()">.</button>
      <button id="backspaceBtn" onclick="backspace()">‚å´</button>
    </div>

    <div class="buttons">
      <button id="addBtn" onclick="submitAmount('add')">Add</button>
      <button id="subtractBtn" onclick="openSubtract()">Subtract</button>
      <button id="clearBtn" onclick="clearHistory()">Clear History</button>
      <button id="resetBtn" onclick="resetBudget()">Reset</button>

      <button id="chartsBtn" onclick="openCharts()">üìà Charts</button>
      <button id="filterBtn" onclick="openFilters()">üîé Filter</button>
    </div>

    <div class="history-header">
      <div id="historyLabel">History</div>
      <button id="toggleHistoryBtn" class="history-toggle">Expand ‚áµ</button>
    </div>

    <div id="history"></div>
  </div>

  <!-- Theme toggle -->
  <div id="mode-toggle" onclick="toggleMode()">üåô</div>

  <!-- ‚úÖ Overlay (click-safe) -->
  <div id="overlay"></div>

  <!-- ‚úÖ Profile menu -->
  <div id="profileMenu" class="profile-menu" role="dialog" aria-modal="true">
    <div class="profile-menu-head">
      <div id="profilesTitle" style="font-weight:900;">Profiles</div>
      <button class="close-btn" onclick="closeProfileMenu()">‚úñ</button>
    </div>
    <div id="profileList" class="profile-list"></div>
    <button class="btn" onclick="addProfile()">‚ûï Add</button>
  </div>

  <!-- ‚úÖ Settings modal -->
  <div id="settingsModal" class="modal" aria-modal="true" role="dialog">
    <h3 id="settingsTitle">Settings</h3>
    <hr />

    <h4 id="languageLabel">Language:</h4>
    <button class="btn" onclick="toggleLanguage()"><span id="langBtn">Switch to Arabic üá∏üá¶</span></button>

    <h4 id="currencyLabel">Currency:</h4>
    <select id="currencySelect" class="mb-select">
      <option value="USD">USD ($)</option>
      <option value="QAR">QAR (ÿ±.ŸÇ)</option>
      <option value="EUR">EUR (‚Ç¨)</option>
      <option value="GBP">GBP (¬£)</option>
      <option value="SAR">SAR (ÿ±.ÿ≥)</option>
      <option value="AED">AED (ÿØ.ÿ•)</option>
      <option value="JOD">JOD (ÿØ.ÿß)</option>
      <option value="KWD">KWD (ÿØ.ŸÉ)</option>
    </select>

    <h4 id="featuresLabel">Features:</h4>

    <label>
      <span id="toggleCentsLbl">Smart cents input</span>
      <input type="checkbox" id="toggleCentsMode" />
    </label>

    <label><span id="toggleClearLbl">Show Clear History</span><input type="checkbox" id="toggleClear" /></label>
    <label><span id="toggleResetLbl">Show Reset</span><input type="checkbox" id="toggleReset" /></label>

    <!-- ‚úÖ Quick amounts editor -->
    <h4 id="quickLabel">Quick Amounts:</h4>
    <div id="quickEditor" class="quick-editor"></div>
    <input id="quickNew" type="number" inputmode="numeric" placeholder="Add amount (ex: 7)" />
    <button class="btn" onclick="addQuickAmount()">Add Quick Amount</button>

    <!-- ‚úÖ PIN settings -->
    <h4 id="pinLabel">PIN Lock:</h4>
    <button class="btn" onclick="openPinSettings()">üîí PIN Settings</button>

    <!-- ‚úÖ Categories -->
    <h4 id="categoryLabel">Custom Categories:</h4>
    <div id="categoryList"></div>
    <input type="text" id="newCategoryInput" placeholder="Add new category" />
    <button class="btn" onclick="addCategory()">Add Category</button>

    <button class="btn" onclick="closeSettings()">Close</button>
  </div>

  <!-- =========================
       ‚úÖ CHAT WIDGET (bottom-left)
  ========================== -->
  <button id="gpt-fab" type="button" aria-label="Chat">üí¨</button>

  <!-- History tab & drawer (RIGHT) ‚Äî only shows when chat open -->
  <div id="gpt-history-tab" role="button" aria-label="Chat history">History</div>
  <div id="gpt-history-drawer" aria-label="Chat history drawer">
    <div class="gpt-history-head">
      <div style="font-weight:900">Chat History</div>
      <button class="close-btn" type="button" onclick="closeHistoryDrawer()">‚úñ</button>
    </div>
    <div class="gpt-history-list" id="gpt-history-list"></div>
  </div>

  <div id="gptWidget" aria-label="Chat panel">
    <div class="gpt-header">
      <div class="gpt-title">ChatGPT</div>
      <button class="gpt-close" type="button" onclick="setChatOpen(false)">‚úñ</button>
    </div>
    <div class="gpt-messages" id="gptMessages"></div>
    <div class="gpt-inputbar">
      <input id="gptInput" type="text" placeholder="Type a message..." autocomplete="off" />
      <button id="gptSend" type="button">Send</button>
    </div>
  </div>

  <script>

    // ===== GPT Chat Logic (FIXED TITLES) =====
    const gptFab = document.getElementById('gpt-fab');
    const gptWidget = document.getElementById('gptWidget');
    const gptMessages = document.getElementById('gptMessages');
    const gptInput = document.getElementById('gptInput');
    const gptSend = document.getElementById('gptSend');

    const gptHistoryTab = document.getElementById('gpt-history-tab');
    const gptHistoryDrawer = document.getElementById('gpt-history-drawer');
    const gptHistoryList = document.getElementById('gpt-history-list');

    let gptSession = [];
    const GPT_HISTORY_KEY = 'mb_gpt_history_v2';

    function loadGptHistory(){
      try { return JSON.parse(localStorage.getItem(GPT_HISTORY_KEY)) || []; }
      catch(e){ return []; }
    }
    function saveGptHistory(list){
      localStorage.setItem(GPT_HISTORY_KEY, JSON.stringify(list));
    }

    function renderHistoryList(){
      const all = loadGptHistory();
      gptHistoryList.innerHTML = '';

      if (!all.length){
        gptHistoryList.innerHTML = '<div style="opacity:.8;font-weight:900;text-align:center;padding:12px;">No history yet</div>';
        return;
      }

      all.slice().reverse().forEach((conv, idxRev)=>{
        const idx = all.length - 1 - idxRev;
        const div = document.createElement('div');
        div.className = 'gpt-history-item';
        div.textContent = conv.title || ('Chat ' + (idx+1));

        div.onclick = ()=>{
          gptMessages.innerHTML = '';
          gptSession = (conv.messages || []).map(m => ({
            role: String(m.role).toLowerCase().trim(),
            content: String(m.content)
          }));
          gptSession.forEach(m => addBubble(m.role, m.content, false));
          closeHistoryDrawer();
        };

        gptHistoryList.appendChild(div);
      });
    }

    function addHistoryConversation(messages){
      const cleaned = (messages || [])
        .filter(m => m && m.role && m.content)
        .map(m => ({
          role: String(m.role).toLowerCase().trim(),
          content: String(m.content)
        }));

      if (!cleaned.length) return;

      // ‚úÖ Title = first USER message (NOT assistant ‚Äúhello‚Äù)
      const firstUser = cleaned.find(m => m.role === 'user' && m.content.trim().length);
      const title = (firstUser ? firstUser.content : cleaned[0].content).trim().slice(0, 40);

      const all = loadGptHistory();
      all.push({ title: title || 'Chat', messages: cleaned, ts: Date.now() });
      saveGptHistory(all.slice(-30));
      renderHistoryList();
    }

    function closeHistoryDrawer(){ gptHistoryDrawer.classList.remove('open'); }
    window.closeHistoryDrawer = closeHistoryDrawer;

    function setChatOpen(open){
      document.body.classList.toggle('gpt-open', open);
      gptWidget.classList.toggle('open', open);

      if (open){
        gptSession = [];
        gptMessages.innerHTML = '';
        renderHistoryList();
        setTimeout(()=> gptInput.focus(), 50);
      } else {
        addHistoryConversation(gptSession);
        gptSession = [];
        gptMessages.innerHTML = '';
        closeHistoryDrawer();
      }
    }
    window.setChatOpen = setChatOpen;

    function addBubble(role, text, pushSession=true){
      const div = document.createElement('div');
      div.className = 'gpt-msg ' + (role === 'user' ? 'user' : 'assistant');
      div.textContent = String(text || '');
      gptMessages.appendChild(div);
      gptMessages.scrollTop = gptMessages.scrollHeight;
      if (pushSession) gptSession.push({ role, content: String(text || '') });
    }

    async function sendToGpt(){
      const text = (gptInput.value || '').trim();
      if (!text) return;

      gptInput.value = '';
      addBubble('user', text, true);

      const typing = document.createElement('div');
      typing.className = 'gpt-msg assistant';
      typing.style.opacity = '0.75';
      typing.textContent = 'Typing...';
      gptMessages.appendChild(typing);
      gptMessages.scrollTop = gptMessages.scrollHeight;

      try{
        const res = await fetch('/.netlify/functions/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ messages: gptSession })
        });

        const data = await res.json().catch(()=> ({}));
        typing.remove();

        if (!res.ok){
          addBubble('assistant', data?.error || data?.message || ('Error ' + res.status), true);
          return;
        }

        addBubble('assistant', data?.reply || data?.text || 'No reply', true);

      } catch(err){
        typing.remove();
        addBubble('assistant', 'Network error. Check Netlify functions + deploy.', true);
      }
    }

    gptFab.addEventListener('click', ()=> setChatOpen(true));
    gptSend.addEventListener('click', sendToGpt);
    gptInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') sendToGpt(); });

    gptHistoryTab.addEventListener('click', ()=>{
      renderHistoryList();
      gptHistoryDrawer.classList.toggle('open');
    });

    // ‚úÖ Fix: if overlay ever gets stuck, unstick it so clicks work again
    window.addEventListener('load', ()=>{
      const ov = document.getElementById('overlay');
      if (ov){
        ov.classList.remove('active');
        ov.style.display = 'none';
      }
    });
  
  
/* =========================
   ‚úÖ PATCH: overlay z-index + click-through fix
========================= */
(function(){
  const overlay = document.getElementById('overlay');
  if (overlay){
    overlay.style.zIndex = '5000';
  }
  // ensure app stays clickable when overlay not active
  if (overlay && !overlay.classList.contains('active')){
    overlay.style.pointerEvents = 'none';
  }
  const obs = new MutationObserver(()=>{
    if (!overlay) return;
    if (overlay.classList.contains('active')){
      overlay.style.pointerEvents = 'auto';
    }else{
      overlay.style.pointerEvents = 'none';
    }
  });
  if (overlay) obs.observe(overlay, {attributes:true, attributeFilter:['class']});
})();

/* =========================
   ‚úÖ PATCH: chat open/close shouldn't block app
   ‚úÖ PATCH: chat history dedupe + show only when chat open
========================= */
(function(){
  const gptFab = document.getElementById('gpt-fab');
  const gptWidget = document.getElementById('gptWidget');
  const gptMessages = document.getElementById('gptMessages');
  const gptInput = document.getElementById('gptInput');
  const gptSend = document.getElementById('gptSend');

  const gptHistoryTab = document.getElementById('gpt-history-tab');
  const gptHistoryDrawer = document.getElementById('gpt-history-drawer');
  const gptHistoryList = document.getElementById('gpt-history-list');

  if (!gptFab || !gptWidget || !gptMessages || !gptInput || !gptSend) return;

  let gptSession = [];
  const GPT_HISTORY_KEY = 'mb_gpt_history_v2';
  let gptIsOpen = false;

  function loadGptHistory(){
    try { return JSON.parse(localStorage.getItem(GPT_HISTORY_KEY)) || []; }
    catch(e){ return []; }
  }
  function saveGptHistory(list){
    localStorage.setItem(GPT_HISTORY_KEY, JSON.stringify(list));
  }
  function closeHistoryDrawer(){
    if (!gptHistoryDrawer) return;
    gptHistoryDrawer.classList.remove('open');
  }
  window.closeHistoryDrawer = closeHistoryDrawer;

  function addBubble(role, text, pushSession=true){
    const div = document.createElement('div');
    div.className = 'gpt-msg ' + (role === 'user' ? 'user' : 'assistant');
    div.textContent = String(text || '');
    gptMessages.appendChild(div);
    gptMessages.scrollTop = gptMessages.scrollHeight;
    if (pushSession) gptSession.push({ role, content: String(text || '') });
  }

  function renderHistoryList(){
    if (!gptHistoryList) return;
    const all = loadGptHistory();
    gptHistoryList.innerHTML = '';

    if (!all.length){
      gptHistoryList.innerHTML =
        '<div style="opacity:.8;font-weight:900;text-align:center;padding:12px;">No history yet</div>';
      return;
    }

    all.slice().reverse().forEach((conv, idxRev)=>{
      const idx = all.length - 1 - idxRev;

      const div = document.createElement('div');
      div.className = 'gpt-history-item';
      div.textContent = conv.title || ('Chat ' + (idx+1));

      div.onclick = ()=>{
        gptMessages.innerHTML = '';
        gptSession = (conv.messages || []).map(m => ({
          role: String(m.role).toLowerCase().trim(),
          content: String(m.content)
        }));
        gptSession.forEach(m => addBubble(m.role, m.content, false));
        closeHistoryDrawer();
      };

      gptHistoryList.appendChild(div);
    });
  }

  function addHistoryConversation(messages){
    const cleaned = (messages || [])
      .filter(m => m && m.role && m.content)
      .map(m => ({
        role: String(m.role).toLowerCase().trim(),
        content: String(m.content)
      }));

    const firstUser = cleaned.find(m => m.role === 'user' && m.content.trim().length);
    if (!firstUser) return;

    const lastUser = [...cleaned].reverse().find(m => m.role === 'user' && m.content.trim().length);
    const sig = `${cleaned.length}|${firstUser.content.trim().slice(0,60)}|${(lastUser?lastUser.content:'').trim().slice(0,60)}`;

    const all = loadGptHistory();
    const last = all[all.length - 1];
    if (last && last.sig === sig) return;

    const title = firstUser.content.trim().slice(0, 40);

    all.push({ title: title || 'Chat', messages: cleaned, ts: Date.now(), sig });
    saveGptHistory(all.slice(-30));
    renderHistoryList();
  }

  function setChatOpen(open){
    if (open === gptIsOpen) return;
    gptIsOpen = open;

    document.body.classList.toggle('gpt-open', open);
    gptWidget.classList.toggle('open', open);

    if (open){
      gptSession = [];
      gptMessages.innerHTML = '';
      renderHistoryList();
      closeHistoryDrawer();
      setTimeout(()=> gptInput.focus(), 50);
      return;
    }

    const hasUser = (gptSession||[]).some(m =>
      String(m.role).toLowerCase().trim()==='user' && String(m.content||'').trim()
    );

    if (hasUser) addHistoryConversation(gptSession);

    gptSession = [];
    gptMessages.innerHTML = '';
    closeHistoryDrawer();
  }
  window.setChatOpen = setChatOpen;

  async function sendToGpt(){
    const text = (gptInput.value || '').trim();
    if (!text) return;

    gptInput.value = '';
    addBubble('user', text, true);

    const typing = document.createElement('div');
    typing.className = 'gpt-msg assistant';
    typing.style.opacity = '0.75';
    typing.textContent = 'Typing...';
    gptMessages.appendChild(typing);
    gptMessages.scrollTop = gptMessages.scrollHeight;

    try{
      const res = await fetch('/.netlify/functions/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ messages: gptSession })
      });

      const data = await res.json().catch(()=> ({}));
      typing.remove();

      if (!res.ok){
        addBubble('assistant', data?.error || data?.message || ('Error ' + res.status), true);
        return;
      }

      addBubble('assistant', data?.reply || data?.text || 'No reply', true);

    } catch(err){
      typing.remove();
      addBubble('assistant', 'Network error. Check Netlify functions + deploy.', true);
    }
  }

  gptFab.addEventListener('click', ()=> setChatOpen(true));
  gptSend.addEventListener('click', sendToGpt);
  gptInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') sendToGpt(); });

  if (gptHistoryTab && gptHistoryDrawer){
    gptHistoryTab.addEventListener('click', ()=>{
      renderHistoryList();
      gptHistoryDrawer.classList.toggle('open');
    });
  }

  // close chat on ESC without double-saving
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape') setChatOpen(false);
  });
})();

</script>

  <script src="/pwa-bridge.js"></script>
</body>
</html>
